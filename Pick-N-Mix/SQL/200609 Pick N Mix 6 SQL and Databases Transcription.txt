Okay, welcome everyone. And what we're going to talk about this evening is introduction to SQL databases. This whole originally given a few weeks ago for the data service. This is a slightly expanded version of it. But it's basically the same information. What we're gonna do is look at what a database aids the fact that we have different types of databases. One way you might want to use a database rather than some other software tool, so time that when a desktop isn't enough, because possibly a lot of you will use programming languages like Python or R or what have you to do data analysis and work with datasets, but sometimes a database is the way to go. After that, we'll be using SQL to that that is the start of the day. demonstrations I'm going to do. And basically, we're going to start with the database already. And then we're going to look at the various aspects of SQL and how you would use SQL to extract data from that database. So we'll start right at the beginning, we worked our way up into somewhat more complex type of SQL queries, but nothing, nothing too heavy, certainly. What also was part of that look at the database interface, I how we as users actually get access to the database and the data stored on it. And there's various ways of doing that, as we'll see, but we'll go through one or two. And then we look at the other ways of interfacing to a database. And again, they're sort of related to database interfaces is the standard way of what you might use if you're developing SQL queries. But ultimately, you want some different way of having those SQL queries And that's where the other ways of interfacing come into it. So what is a database? That's thought for answers that but nothing really the time. So what is this? If you've probably all got an idea in your heads, what databases? So what is a database? Well, in code, any collection of data, a database, essentially. So there's a database. But generally speaking, you wouldn't think of that as a database. There's something a little bit more nuanced about what a database actually is. And typically, what distinguishes a database from my little rubbish bin there is that the data in a database is structured in some way. And it's structured specifically in ways which allow the retrieval of the data from it, which means you have to be careful when you put in a day so as you can get it out in a nice using them. And most circumstances, you will want all of the data, you're only one part of it. And they're in sorted rise. The problem because a lot of the databases you may come across are very large datasets. And you'll want to tell me a bit. So what we need to have is some mechanism, which is going to allow us to extract just the basic tools. You do 48 different types of databases. Now, all databases store data, that's fine. But they don't all store the data in the same way. Sometimes we don't really care how the data is stored as long as we get it out again. But there are other circumstances where again, if you have very large databases, then how it is stored can affect the efficiency of our queries. And that may become important and how we actually write the queries in the first place. before we're doing that Seriously, then we don't really have to worry about too much. Different types of databases. Well, we'll look at SQL tonight. So SQL relational databases where we are looking at honing in on today. And that consists of tables which are related to each other in some very clearly well determined way. Whereas, and the way we do this is we use keys and two fields which share common information, and allows us to relate those two tables together. And you can do this with multiple tables. We use SQL or SQL query to retrieve the data from relational databases. We also now have no SQL databases. And in the no SQL databases, databases rather, rather than being stored in tables, the data is stored as collections of documents. documents can have complex structures and they can So tables, which we all know have rows and columns, in no SQL database, the documents can be quite complex structures. And because they're complex structures, we can't easily use SQL to extract the data from. Now, having said that some of the modern database systems like my SQL and Microsoft server, they now allow you to have unstructured data in there. And they provide some mechanisms for using SQL to extract the data, but it's more of a function than anything else. So in general, for no SQL database or no SQL data, we don't use us for access to data. And I just hit the bottom there, just Just be careful use the terms again, an SQL table is equivalent to a no SQL collection. An SQL table row is no SQL document. But we're only interested in SQL tables for relational database, arranged in tables that I've just said, and this is very much like you seen a spreadsheet, this is a digit. We always talk about relational database tables. Just think spreadsheet, rows and columns can't go far all the rows and columns and columns or have their own column names. And perhaps unlike a spreadsheet, like Excel, or what have you, what is slightly different about these tables of rows and columns is that give it for a given column, all of the values for that column and the different rows have to be of the same data type. Whereas in Excel, you can put anything in any cell you like. So that's not quite set, here, for a database within a column, everything else of the same data type. And we'll see that when we look at the definition of some of the tables. Internally, database Ted, not quite the same. spreadsheet. But as I say, Just think of it as a table. And we can go through what we're doing. So here we are. This is a spreadsheet of data. This is in fact a bit of the data we'll be using later on rows and columns. But we're going to use that as a database table or we have put that into a database and therefore access it as a table using SQL. Now, why is it a relational database? I think you probably already mentioned this possible it is possible have a database with only one table. In general, a given database will be happy will have many tables, not a small world, they will many of them will be related to each other. You can have independent tables but generally speaking the point of corner relational database is that the tables within it have best some relation to each other. Not all to each other. Every one of them, but tables would have relationship, different tables. So I think we haven't all sort of pre pre computed, for example, here ever sales receipts from some kind of shop in America balance. Okay, you probably all Well, I'm adding quite a lot to the theme seeing things like this. It's a little tab and you get lots of information there. And this is related, some kind of sale, some sort of hippie thing very huge who the customer is when it happens, names and addresses, how they paid details down here of all the things that they're bought, and how much it has to pay received by the seniors. So you see lots of information on this single, apparent simple form, relatively simple form. But if we were putting that into a database, we wouldn't this would not represent any Row in a table, because there's too many different things in there too many different things going on in there. So what we would typically do for making this into a database, we would split it up. So all days, which is you see, it doesn't really have much associated with it is the whole sheet if you like, but we break that out into separate components. So we've got the order details up here. We've got accounts down here. totals and taxes and what have you. Put me here for payment details customer details appear. So you can imagine in a database, you have a table called perhaps customers, and a table called orders, table called order details and so on and so forth. And these are all related to each other in a relatively obvious way. If you've got an order, someone placed the order if you've got an order. They must consist of ordering some items. If you've got an order, you've got to know how much that order how much they paid for that order. If you've got an order, you want to know how they paid that and things like that. So you see how that naturally split down into a set of tables. But each of the tables are related to one another in some way, or related back to the orders. The orders itself, the table stuff, I haven't put it down here. But essentially, all you need in the Orders table, or links, or keys, key values, which match entries in the four tables. Yeah. So let's go into multiple tables. And the advantage of using multiple tables is that you use small amounts of data, you've got small amounts of data to manipulate. So if I just go back to this one, and someone wanted to work out and these are all individual items that you all If you wanted to know how many pink widgets you sold, you just need to access this table here. You don't need to know who you sold to, or how much they paid for. Yeah, if you want to do a main shot, you only need the Customers table. You don't need to know how they normally pay or other things like that. The security of the data again back to this, the people feel in the in the warehouse, you've got to do the reordering need to know who what has been sold. But they don't need to know anything about the accounting information. That's for accountants. Disadvantages, it slows up data because for all this here, this is an order that we need to access for other different tables. So here it is to see how that's going to slow things down. And more complex queries again, if you do need to access from multiple tables, so for example, a pay as I suggested, if you're going to do a main shot, you just need the customer address details. But reality is you probably want to do the main shot to your added 100 best customers, in which case, you need to reference orders to see what the desktop isn't big enough, right? databases can be very, very large gigabytes, millions of records. We'll see that a bit later on. And so too big stone in desktop may not be yours anywhere, you may just have access to the data, and perhaps not also related not being yours. And the data which you have acquired in some way, maybe offered, take it or leave it. And if you only want a small part of that data, it's still going to be down to you to extract the bits of data you walk in if you lose 90% So so you may only be interested in some of the tables or parts of some of the tables either. Easy, either. Fortunately, database systems make it easy to show. And that's what we'll do. This is what the SQL database environments, and it's not a single programme like Excel is it in a database system, you typically have two main parts the database engine, which is responsible for actually storing the data, and the system which actually define what type of database it is, whether it's an oracle database or my SQL database, or whatever that is, and it also has to be able to interpret and act on SQL requests, it was going to receive SQL requests, it's going to return the data from those SQL queries. On the other hand, the user interface is how we talk to this database system is compelling in many different forms. What is normally the case is all database systems will come with a preferred user interface, some kind of query, we'll have a look a couple of them. And so what we have if you take Microsoft Access, which is a database system, now unusually, this is one where the GUI and the data database engine to come in a single package bearing Microsoft Access, instal at Microsoft Access, and you get both of those installed automatically. But more common, and we're doing it for the bigger boys on the block are a gimme on the database. And now again, typically, if you're installing any of those, you would have the option of installing configuring the database engine once, but you're not obliged to do so. They can have separate applications, the 10th as a package here, they're normally but separate applications. So what you could do is you could decide Not to instal and use, you can get away with not so and database engine because that's what's going to store all your data. All right. But if you don't want to use the GUI provided, you can substitute with another query, or you can use other tools to connect to the database. And so here we have a selection of database tracks as you like we'll be using later on in my division later on. And here we have different ways of accessing these database engines. So in access programming languages like R and Python, we can use Excel. We can use SPSS or Stata or virtually anything else. For the standalone dv, as I said, most of them will come with their own preferred, but for example, MySQL Workbench comes with mice, or yes comes as part of my SQL DB browser for SQL lite, which is what we're going to use just a few clicks. Paul as part of sto life, but it is dedicated to using SQL DB, there is a GUI which allow you to access virtually any type of database you might want very heavy duty, big beasts on the Roku app. And you can even access your databases from sophisticated text editors like VS code and a few others. Not necessarily ideal, but it can be done. What is perhaps worth pointing out below, you quite commonly will use R and Python or SPSS access devices, you're still typically or quite often you'll still be writing SQL queries. And so you need a way of developing and testing those queries. And that's where the gooeys come in. Because again, these are designed as IDs integrated data development environment. To help you do your development work, differently user access are his use access programmes are separate, as we've said, and they don't even have to be on the same machine. They do, he should be on your desktop or laptop, because that's where you're going to type your or create your SQL queries. But the database engine could be on a far larger machine dedicated to serving databases. So give me a database engine together. That's one possibility. We can separate the desk, the Union, the desktop and the database engine on the server. And the reality is that what you have for your cue might be your little desktop. Whereas the database engine could be on a very, very large server, which is going to allow you to use bigger databases, and it is going to do all the work for you. You just have to send your request and get the results. Perfect. So that's the background of the database environment. So now, if it's an SQL, two basic types of SQL commands, DDL statements and DML, statements, DDL data Definition Language, and these are the state the statements or settings that you use to create your database or create your tables. And in generally manage the environment will allow you to get very few of those when we create some tables later on. The majority of what we learn what we're interested in is data manipulation language. And these are segments which choose to actually deal with the data, put data into a table, delete it from the table, update data from the table. And in our case, very importantly, reading from the table that most of what we want to do is reading data from tables. So this just shows again, the DML statements Create, insert, record, read, select. That's what we'll be using select inside, update and delete and collectively referred to as crud statements. The one we're really just again, it's a second on the select statement. It's not much of an exaggeration to say that most of your time using SQL will be writing SELECT statements. You only create a database once you typically set the table at once. You may have to update records or add new records. But typically most of your time is spent in querying records using SELECT statement. And especially if you've inherited this data, but you're not gonna be updating your own query data. So what can we do in a sec query? Well, we can select specific columns from a table or tables. This is referred to in the jargon as public. Selecting specific columns, we can select specific rows from a table or table. And this is known as selection, projection and selecting here, we can add new columns, which is, I suppose form of projections, well, your base and existing columns on using the variety of built in functions aggregations from the rows in the table by grouping values in one or more of the columns and summing them up in some way. All of these perhaps with fusion three here, all of these typically reduce the amount of data you're working with. Because if you've got a table with 100 columns, and you only need 10 of them, you're only going to select 10 columns by selecting specific rows, so for example, later on, we have a table which has some dates in it. Oh, yes. And it's and if you're not a particular year, All arrests can be ignored. So again, we're honing in and reducing the amount of data we have to worry about. And then aggregations, naturally, something together and gives you summarised information. We saw the outputs are based on one or more of the columns. And very importantly, because this is a relational database, we can join tables together using a common key. And what we might need to know and there's nothing in a select statement that can affect the underlying data in the tables. Once that data is in a select statement can't change data. Even when you're creating new columns, as you suggested we can do, you're just creating those columns in the output of your query. It doesn't affect the underlying tables. The output of a select is always a table, even if there's only one row one column. So very typical. So the query is how many rows in my table as just as one numeric answer with that is still a table with one row one column. There's ways of saving outputs from a select query, you could either save it as another table, or a view, which is very similar to a table that fits in very clearly with the statement that everything returned from a query is a table. So you can save it as a table. But you can also output it to CSV files in real life. And of course, because tables, we have this mental image of a table being a spreadsheet of rows and columns, it's very obvious that you can always output this to a CSV file quite naturally. Oh, the demos, the rest of this webinar is diversity demonstrations. I think it's probably true. We'll go look at the girI DB browser for SQL Lite. So if you've got that installed, feel free to Have a look at it as we go through it that easily downloadable instals it's free, no problems. And we're creating but some select query. So just need to come out of there and look at my DB browser environment. Now you just opened this environment by calling up the Divi browser programme. And what you will see will vary depending on if you've just installed it and what have you. But typically, you get on one side you'll get something called the schema and fewer things and they is going to tell me the details about my database, which I haven't opened yet. And then here we've got other little sections, which is probably easiest if I open my database first. So if I go to File, and then you can whoops, far easier, kill to new open or whatever, but down at the bottom Here is a little selection of the recent us ones. So the one I'm going to use is sn 7613. And let me just show you should have probably should have shown you on these slides. Just before I do this, the data sets we're going to use both come from the UK data service. And the first one, you can find it by going to data service and do a search for sn 7613. And what it is it's a census macro data teaching file. It's got about half a million records in it. So it's a reasonable size file for for doing this. And the other one I'm going to show you is this one called EDI RP is referred to as GD Rp. And it is sn 7591. Now this is a very large data set and the version of this we're going to use has 246 million rows. So we've got enough to look forward to. But most of the, the SQL and the demonstrate are gonna be based on this teaching data set. And so hence, it's a hot open my database net. And on this left hand side, what you can see are the number of tables I have in my database. And you can see what these tables are called. In fact, this one here is the only one which comes from that sn number. All of the rest I have created based on either this or other information I've got from the data service. We'll have that bit later on. So these are tables. I'm going to put reviews here which I like recreate later on. These are very, very similar to tables to the extent that I can't have a table and a view with the same name. Okay, but we We'll come back to views later on. Just on the left hand side, in the main section down here, it's split into three segments. And these are just all sorts of things.So this bottom section here, it says results of the last exit. So it's really showing you the messages about what it did. So if anything goes wrong, this is where the error messages crop up. This middle section here is going to show me the results of the query. And are shown to me is great because the results of queries always tables, so rows and columns. And up at the top here is where I'm going to write my SQL statements. Our global tab system here, I've got some files already opened. I'm going to use a get add tabs into it and write statements in here. Okay. So I'm gonna start off with the basic SELECT statements. Seems opened up because I've written some of these pretty Obviously, I've got information in these other two sections here. But these will get replaced as I run new queries. So most basic query we can use, I'm going to use this table CMT 11 mod, which is actually this one, which I've derived from there. So it doesn't matter. If you want to see what's in, before you even start, you can go up here to browse data and select the table that you're interested in. And it will just show you in a lot of great information. And if you look at that, that is probably about the same amount of data, as I showed you in that extra from the spreadsheet earlier on. Exactly. So the downside of this data sets for what we're doing is that it's entirely numeric. There's no data no text in there. Hello, I have fixed starts at the end by putting some in myself. But generally speaking, it is all numeric data. deterred after SQL most basic SQL you can write is select star from table name. Okay, this limit 10 at the bottom just says only show me 10 results, I don't want over half a million results from the back. Okay? So I can set all of that and run it. And I hit the box in the spin section here, I am going to get the results of what I've asked for. And at the bottom here, it just says what I ran effectively between 10 rows and 42 milliseconds. Don't necessarily trust the tiles too much. But typically, you don't want to use a star you want to select specific records, or columns of A bomb. So if you want specific columns, you have to name the columns separated by commas. So here I'm only asking for three columns. If I run that idea three times what you can't do you might be tempted to do is you can't use the star as a wild card, he might be able to do it in the system. So if I tried that I get an error error is nice bright red, you're not gonna miss errors, okay? And says no, that's not the right syntax. Little things about the syntax. So we'll just show you live in red squiggly lines that you get in word and like, you might have noticed, so this is nicely colour coded to help me along in terms of what I want. In fact, if I just start here and start saying, select doesn't matter if it's uppercase or lowercase, select it's no I'm just making this up xx free from see the end. As soon as it gets enough of it or three characters, it will try and suggest to me what it is okay? And most Ida type environments will do this sort of thing for you. And that's why we use them rather than just writing little text files with SQL. This is why this is a development environments because you get. So here's just an example where I will do a few more columns. And it shows it. Again, it's all free format, it doesn't really matter how you write it here, spread it out into into multiple rows, I put the commas at the beginning of the rows. This is preference. It just makes it look a bit neater. Selecting rows, that's a projection. So now we're going to look at the selection. I restrict in the columns are different than that. shooting the rows. So here again, I've selected various columns using the same table. But here I've got a where clause saying where gender equals female. So if I select those, if I run that query, what I get back, as you can see, all the genders are female. Yeah, we can make this a bit more complex. So on this one here, much the same set of columns I want, but here I've got gender equals female and regional lesson three, and I'm using brackets here. To put this double or statement of age group eat equals one or age group is greater than six, okay? The brackets are used only so they're only using whatever you like, but generally they use to enforce precedence rules. I'm there, I'll be honest. I'm actually here to check out. I'm just accepting that I've got the right answer. So you can, we can break this down into various parts and then separately, in any reason I split this out because I wanted to demonstrate that if I just do the first part, I get to in 89,000 rows back, the second part 97,000 rows back, the third party it would be good 106,000 hundred 58,000. But if I run the whole lot together, I'm down to 23,929. The general effect is that when you're adding things together, either reduce the size, if you're ordering things, you tend to increase the number of rows being returned. We're not restricted to the simple arithmetic type operators or Boolean operators here. We've got a few extra words that we can use. So what we can do is here we're using age group greater than two and age group less than or equal to six. Well as an alternative to that, we can actually use this between keywords and say between three and six, which is obviously a bit muted right now. And we can also use the in keyword and then in bracket and put the list of the values that we're prepared to accept. So hopefully you can see that all these last 370 haven't run so let me just run them. We should end up getting exactly the same results to be nice 7643 to be nice night 7643 and Exactly, again. So there's three different ways of saying the same thing with exercise. The other thing we can do is use this like key word. and here we can in terms of the values of within a column, we can use no life keyword, we can use percent as wildcards. Okay, so anything with North, we don't care what it starts with. We don't care what comes after the North, anything which has north in it. You want to know about that. So northeast, nothing if I go far enough, I'll probably get Northwest in there as well. But you get the idea. You can only do this if you're using the right keyword you didn't have I could have left those percent signs out just north and they would master exactly know that, okay, ruins the quality of it. And again, I could say like North East. So it's got to start with the Northeast, and I don't care what follows the Northeast. And here's just an example of the majority of the query is just things that we've had before laid out differently using arms and ns and betweens and what have you. The differences here is I'm introduced this order by yen. And this is just sorting, basically, so package. By default, it will sort in ascending order. If I want to sort something in descending order I can use I could put the word desk at the end. And if I were not at the highest age group is first eight. far enough, I'll go down to the sevens and what happened? And more, much to say won't go through all of these. So they're the basic things of selecting columns selecting rows aggregations. Next thing, what to do is how do we group things together? I'm just gonna sew here, how do you do that? Well, we can use it the set of functions provided like count or some or mean or Max and things like that, which will do some kind of aggregation function. And typically the star in there means across all of the records. But if we also add other columns in here, like age group, it will group by that call. And when we do the we mentioned the column Excuse me. I sneeze and, and then we have to end the bottom here we used to squeak by. And we have to say what it is we're grouping by. And the syntax requires us to have named that column up here as well. So here are not see it. So now for each of the value for each value, different value in age group, I get a count of how many times Okay, I can do this across more than one Corp, in which case when I run that, I get more results. And what I what I have for each, each combination of age group and econ aqueon team is Get a count closer, each possible combination for a tuple is only the one there. The for two, I've got the whole list of possible values of this. And it splits them down. I said, one of the options, option three, I think you want them slightly out of order is to create new columns. And there's a variety of ways of creating new columns. I'm not gonna read all of these. And again, creating new columns normally involves you using some of the built in functions. And some of these functions have very similar equivalents in Excel and other spreadsheets. So I'm going to name string function here. Which, if I run that, what this is going to do is tell me position, or within economic activity. This is a new table I'm using here, where this code on occurs. So it is at position 24, some of them and 22 for others. And for this last one, it doesn't appear at all therefore it is here. Okay. So what I can do is I can use that, in that the instrument to find out where this code on occurs and substrate to actually spit the string to one sneeze. What I'm doing is I'm going to split this, the economic activity field up and I'm going to create a new one and I'm going to call this economic type. How do you create a new one? I don't actually have to put that as an economic tip. But by doing so I'm actually now Adding the value that naming the new column. So if I remember that you can see here economic type as I named. And what I've got is what comes after the total. And that little close to the end there that was to get rid of the space and the kernel itself. More complicated ways of doing adding new columns, but the commonly done is using the case statement and this is about as close to programming as we get in SQL. So what we want to do is for the age group, which is number one, two to seven, what age what age and what we're saying is when the age group value is worn, so when worn then I will Math to be the value of my new column. When it's true, I want it to be that and so on. So what you can see is, I'm reversing the way this has been set up, because these were originally age groups in the census survey, and they were allocated numbers. So now I'm just reversing the process. And I'm saying for each of those values, but that those strings now, and if it's none of those values, I'm going to say 75 Plus, and again, I ended with an end there and I get as means I want you can use this name for the call PageRank. So if I wrote all of that, you can see that for the age group, it's allocating into an age range. That new column age range only appears in the output I'm not changing the table at all. Anyway. Tables next. And this is I tell everything we do, many are going to use the select statement. This is just an illustration how you do create tables. I'm not going to run these because this is what I use to create some of these tables up here. So how do you create the table you say create table, you give it a name. And in brackets after the name, you give it your list of columns ID and gender. And against each column, you've got to say the data type that it's going to be. Remember I said how our tables differ from spreadsheets is that the for a given column, all of the values have to be of the same type. And this is what enforces. This purely just create you an empty table. So the next step is well how to put values into there. Well then we use insert into what table is inserted into this Has it agenda and then the values I want a warren male. If you're going to put them in the right order, you can skip the ID agenda and just say insert into sex values to female. For the occupations table again, it's much the same in terms of the created table. But here the values of p values and notice values actually appears once. And I just separate the bracketed list of column values with a comma and go on to the next one. So you can create tables, or one way of creating tables are other ways. And the most common way of creating a table is normally to import from a CSV file, which I'm not going to cover today. But it's very, very straightforward. Union. This is one of the four pillars if you like you SQL, a union is where you're effectively combining two tables together based on the fact that they have the same column names and the same sets of columns. So essentially, you're paying one table to another table to the end of another table. And it also demonstrate this. What I'm going to do is I'm going to create recreate these to Exxon after that click on inactive tables. So the first thing I'm going to do down here, I'm going to drop the view if it exists, that's going to effectively econ after that's going to delete this from happening because it does exist. And I'm going to recreate it. Now this is where you see that. Essentially, these two lines here represents a select statement for the data I want to put into this view. And remember everything Coming back from a select table is a select query is a table. So how do I make it into a table in this case a view which is pretty much the same for what we're doing. I say create view, give it a name and an AZ followed by the Select state. So if you're developing this, obviously after up here, I ran the select statement first to make sure I was working the way I wanted. And I just put that line on top. So if I wrote all of that, this if you do drop the existing table, hopefully no police station Already this, okay, and then the same for the second one. So we'll get to that. And then the actual union. If I do a select from the first one to say union select from the other one. Let me just show you what's in these two tables first. So for their browse data, again, this is just treated with tables have the four entries in that one inactive, I've got six entries in that. Okay. And now if I do the union of select one, Union select the other and remapped. What I get is all 10 rows together, it's worn to the bottom of the year. There's also union distinct which will remove any duplicate rows across the two tables. sent to a mod. I'm not going to run this. This is just an example of a joint statement. And it's a joint image actually used to create the CMT mod. I'm gonna sneeze again I try not to. And the way this works is we start off with the main table, which is your original table. I'm saying what I want to select up here. So everything from this table, which I'm going to refer to as a, I'll come back to that minute. And I want these other things added in as well from these other tables, and then you can see from my table here, my original table, here I've given them what's known as an alias as we'll do we'll name and columns of say this is Table A and then I'm going to do a join These occupations table, which I'm going to refer to as B. And then the condition is that the A occupy occupy for woman T has got to be equal to be the ID in the table. Okay? So what this is this, this ID in the beat table, which is occupations represents a value, which is going to occur in Article One, two of the main table. Okay? Now these little tables have been designed so that the can be used to join in with a main table by using the right set of keys. So if we look at those individual tables, occupations, you see here, this ID one for wall includes minus nine and if I look at the main oops, The main table you can see the values in here at the centre. So we can match up every value in in occupations table with the value in this column here. And that's how we will do the job. Now a slightly more complicated version, we're going to join several tables on to this teaching 11 eW data occupations, region tech, but all doing it in much the same way. So the actual differences when we do run that is this is the original table that we get when we just load it from a CSV file from the data service. And you can see that the end of it down here, it ends with a student and this is all generic stuff. But whereas if I look at my modified version of it. You can see that in the end, I've got these extra columns, which I've just added in occupation in the region code, and so on. Okay, so we can use that add data into our columns. So again, when we join data together, join tables together, you typically expand it in the same with unions or whole nature of that is that you're expanding, you're adding things to your data. Where do I go from there and terms of where to go? What have we seen yet? Even table select a grid, right, that is the end of the basic SQL that I wanted to show you. So we've covered all the key aspects. The select, for columns, the way for rows, aggregation, joins and unions. Now the main things that you're going to want to do with SQL So what I want to show you now is I pointed out when we went into this Divi browser and got our outline the layout of how we see you get details about the database is down here all the tables in a database here, you've got an area for writing your code, you've got an area which gives you results, and you get area for messages. What I want to do now is show you I will touch Yes. Before I do that, I want to show you how we can avoid if we don't want to use the key we want to use something else like Excel, we can do that as well. But the point about using again, is you're using it for development either, right? Yes, well, you're going to check the results. Okay. But obviously having the notes in table Yes, you can export a CSV file. To tomorrow, so if you want to, but we can also use the rights of Excel directly. I'm going to do now. So I'm just going to open up a normal blank SQL book, Excel workbook. And then what I'm gonna do is go to data. And I'm gonna say get data from other sources and the sources and the users Microsoft query. Microsoft queries from the oldest bit of code still in Microsoft Excel. And what will happen is you'll get a window to appear, which allows you to choose your data source at the bottom here. I've got an SQL lite three data source. How did that get in there? It's because I have previously installed the SQL lite three ODBC driver, again, you can get as a free download, and you just do an instal on your machine. You wouldn't need admin rights to do that. I've got mine in there. I'm going to say, okay, it's all up to us. And it comes up with the other one saying, Oh, I know your SQL, like, all I need from you is your database name. And the database name equates to a file name. So I'm going to click on the Browse. I'm going to go to where I think I've hidden this weapon since 7513. And down at the bottom here, you can see our database. This is a database we've been using so far. Before neocon click OK. And this is a problem with Microsoft query. We can get around this it says no visible tables. I click on OK. Oh look, there's no visible tables down here. You get around that by clicking options and toggling the system's tables if it was ticked out with that Check it. And now my tables appears. And you can see, this is a list of all of our tables and views. And so it's already gone out to the database, got that information back and populated this window. Now what I can then do is I can go down for each table, I'll go to a table and select specific columns or whatever I want to move them across. If I say next, it will give me the option of only include rows way. So the previous one here is around two columns. This is affecting my WHERE clause. Here I can do sorting as well. Right? When you've done a lot, it essentially built up enough information for it to write an SQL query form. And if I just say finish now it's going to return that data to excel in this worksheet. What I'm going to do though, I'm gonna say view data or edit query in Microsoft query, and then quickly finish. And this will bring up another window showing the data that's returned, and other bits of information. And reason I wanted to show you that is because within here, there's a little button called SQL. And if I click on that, I can see what the SQL statement it has created on my behalf and will grow to return this data down here. In fact, I can delete all of that and then write my own statement. Select star from pop to when you want to write Click on over there it says, oh, calm representing that graphic below, okay. And we'll click on OK. And you can see there my data from the quote I wrote. And then you're good here to save, turn that and it will write it into my spreadsheet. Okay, so that's how you can, you don't need to worry, I can use Excel. But it means I've got to understand how to write my own SQL queries. Yeah. Which is why you use a GUI to do your development. That is the end of that. done it, save that. Now the next thing I want to show you is sort of finished with that set of data. Now, I want to show you my ask semis for what money SQL. I've got my SQL running on another machine. This is my With a machine or another machine, I want to show you this main window here this bit round, eh, you should really this is just my interface remote interface. So don't worry about that. Within this window here. This is my SQL workbench. So this is standard TV, which comes with my SQL. And all the lot more bells and whistles on this one, but we don't have to worry about that. What I want to highlight to you is that look down here, I've got the refer to a scheme as schema is a database. Unlike SQL lights, you can have multiple databases in in your environment here. So I've got several here these bottom three are the ones which come with the system with my SQL, this one appear EDR P is what I've put in. This is what we're going to be playing with. But you can see again once I expand edlp I've got options For tables and views, and so very similar to my TV browser as your DB browser, in the middle section here, again, I've looked at the top here, I've got a section for writing my queries. When I run a query, it will appear in this little section down here, which disappears when you haven't done anything. And at the bottom here, I get messages saying what I've wrote. Right? The point I'm making is that despite the fact that most rose a fall, bigger beast in SQL light, the gimme is far bigger. But essentially, it said for the same purpose, and it's easy for you to find the equivalent things or what you're used to. That's the environment. What I really wanted to show you this is because this edlp table set of tables here, this gas, a member table, I've set up this machine to sort of be as much of a database server as accountants got a lot more memory than there is a workstation, or a lot of memory in it. Go back to my PowerPoint slides. What we've got here is a workstation with 128 gigs back to it. So it's quite big and make it even more like a server, database server. What I've done is I've created my table. Yes, ma'am. entirely in memory. So wandering around. And this is the table which has 246 million records in it. How do I know that? Well, I have to know how many are but I've got a query here saying select count star from gas and men. And if I run that, it instantly comes back and tells me I've got you know, 46 million there. Now you're thinking that that will not run up pretty quickly, considering 246 million records. In fact, this one's a bit of a sheets because when it was putting the data in it will affect count of how many records are put into those it's sort of already knew the answer to that question. This next one down here though some kilowatt hours. Let me just before I do that, let me just do a little selects from men tend to sort of see what's in here or not guilty. There's only a few columns in here. This last one kilowatt hours is gas usage across the US 246 million records. So this line here, this SELECT statement years, I want you to add up all of these values or 246 million. Okay? So I'm just gonna run that and now Within trigger thumbs for a while and just blow my nose feel it's easy for me to eat myself. Okay, now let's come back in. If I go down to the bottom here, this message at the bottom, blah, blah, blah, some kilowatt hours. It's written took 28.9 seconds, it's pretty impressive, okay? But that is because I've got it all in them and various other things. So now I've got this one last query I'm gonna run here. This is a bit more complicated, so I'm going to select count as household. So that's just you And Name column name. I'm going to put my simple hours in there and call our total energy from gas man. And then we're going to we're tossing where the yay equals oh nine, and the month is August. All right, so slightly more complicated query. If I run that, given that my last one took 29.9 seconds, do you think this is gonna run faster or slower? That's technical, put your hands up, but I'll just let you imagine that while I run it. Okay, seven to server seven seconds, who guessed? That would run faster? Anyone? So the question is, I think we'll probably all make a guess it would run slower if it's more complicated. Why did it run faster And the reason that run faster was mainly because of this month equals all the year. Because not only have I set this table to be in memory, I've also created what's called some indexes on this add index for the year and add index for the month. And the effect of adding indexes means it has a short put roots of finding the months of August or whatever. So if you just think about it in terms of the month, I've got 246 million records sort of distributed across 12 months. If I'm telling it, I'm only interested in August, you can immediately imagine that I'm only gonna have to look at 12 of the records. Yeah, so it runs a lot more efficiently and just fine. Now, the last thing I wanted to show you is, you remember that on my slides, this is the relevant slide. I told you that the workstation, the engine can be separate from your query or environment here. So one of the family is my little workstation up here, one we've just seen running. And I've also got a little Raspberry Pi. Okay, now there's no way I could run a database with tuning for 6 million records. In a Raspberry Pi, we're doing a two gig of memory. Okay, but just to show, what I'm going to do is open up a link to my Raspberry Pi, the Raspberry Pi to create a Raspberry Pi, and then I'm going to collect my database, my SQL I need to say my name As you go by Mr user name, followed by minus h. This is going to be the host address, I've got two point net, not my local Raspberry Pi, but at the workstation. This is 192164 sex. And then finally I'm going to need to provide a password which I'm going to let it prompt. Okay as the passwords of each I'm now in the my SQL. It's not a few years, such as just a little command line, but I can still run queries from here. And the first thing I have to do you may recall, I pointed out that in my SQL in the environment, you can have multiple databases and we want to use EDR p one. The first thing I've got to do is say use DRP and I was terminated learned of semicolon and now you can see database changes now told me that I'm on a DRP. So now I can run my SELECT statements. And what I'm going to do the cheat. I'm just going to take that last one that we ran here oh no Chelsea, check on that. So back to my Raspberry Pi, paste that in Revit there you can see it's come back with the answer in approximately the same amount of time it took me when I was actually really bonded to the point about this Hello, I might be using a small machine for my development, I can still access a remote database server and have it do all the heavy work. I don't have to have it on my machine. I'm just using the command line here. But you could have brought that back into a Python programme and so on and so forth. I think with that, just very Finally, the last slide or signals. If you did want to run it in Python code, here's an example of some Python code. This isn't really about programming Python, the only thing I want to point out to you is, well, what is it you need, you need to have the SQL lite three imported in there. But you can see here, this con statement here called equals, and then I'm just connecting to my database file. Because the database is all in a single file name. And then here SQL, I'm just writing My SQL statements and then when I run that little bit more code, they're gonna remember, we can see that here. It's listing the occupations table. And with that, I am finished. Thank you very much. 

Transcribed by https://otter.ai
